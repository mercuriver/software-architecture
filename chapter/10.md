# 레이어드 아키텍처 스타일

- 레이어드 아키텍처(Layered architecture), n티어(n-tier) 아키텍처라고도 불림

- 가장 흔한 아키텍처 스타일 중 하나, 사실상 표준에 가까운 아키텍처

- 단순하고 낮은 비용으로 구성 가능, 프로젝트 시작 시점에 선택하기 좋음

- FE, BE, DBA가 있는 회사의 소통 구조와 전통적인 레이어드 아키텍처는 그 형상이 유사하다(콘웨이의 법칙)

`묵시적 아키텍처(architecture by implication) 안티패턴`, `우발적 아키텍처(accidental architecture) 안티패턴` 등 몇몇 안티패턴 범주에 속한다

> 묵시적 아키텍처(architecture by implication) 안티패턴
>
> 묵시적 아키텍처 안티패턴은 시스템의 구조가 명시적으로 정의되지 않아 유지보수와 확장이 어렵고, 성능 등을 저하시키는 문제다
>
> 대표적으로 "Big ball of mud" 문제가 있다
>
> 레이어드 아키텍처는 시스템을 레이어로 나눠 독립적으로 동작하도록 설계하는 패턴이다. 하지만, 인터페이스를 명확히 정의하지 않으면 묵시적 아키텍처가 되어 유지보수와 확장이 어려워진다. 따라서, 명시적 아키텍처를 위해 인터페이스를 정의하고, 의존성 억제하기 위해 주의해야 한다

> 우발적 아키텍처(accidental architecture) 안티패턴
>
> 우발적 아키텍처 안티패턴은 시스템이 일관성 없이 발전해 문제가 생기는 것을 뜻한다. 이는 명시적인 계획 없이 시스템이 발전되는 것이 원인으로, 일정한 아키텍처 디자인 원칙과 계획을 수립하여 예방할 수 있다
>
> 레이어드 아키텍처는 레이어 간의 인터페이스를 명확하게 정의하지 않는 경우, 우발적 아키텍처가 될 수 있다. 이때 시스템은 묵시적인 구조를 가지게 되어 유지보수와 확장이 어렵고 복잡도가 높아진다

## 10.1 토폴로지

- 도메인 분할 아키텍처의 반대인 기술 분할된 아키텍처다, 즉 컴포넌트를 도메인 단위가 아닌 기술 역할에 따라 묶는다

- 일반적으로 프레젠테이션, 비즈니스, 퍼시스턴스, 데이터베이스의 4개 표준 레이어로 구성된다

- 프레젠테이션, 비즈니스, 퍼시스턴스 레이어를 단일 배포단위로 합한 후 데이터베이스를 분리하는 등 배포를 기준으로 물리적 계층화 관점에서 다양한 토폴로지 변형이 가능하다

- 온프레미스(on-preises) 제품들은 데이터베이스를 내장하거나 인메모리 데이터베스를 사용하여 4계층을 모두 단일 배포 단위로 묶은 형태를 많이 사용한다

- 각 레이어는 주어진 요청을 처리하는데 필요한 업무 위주로 추상화 되어 있다

  - 프레젠테이션 레이어, 모든 유저 인터페이스와 브라우저 통신 로직을 제어한다, 데이터 조회에 대해선 전혀 알 필요가 없고 오직 화면에 표현하는 것에만 집중한다

  - 비즈니스 레이어, 프레젠테이션 레이어로부터 받은 요청을 알맞는 비즈니스 규칙에 맞추어 처리한다. 화면에서 어떻게 데이터를 표현할것인지 전혀 관여하지 않는다

- 관심사의 분리 개념을 적극활용한 아키텍처로, 이러한 개념 덕분에 아키텍처 내부의 역활과 책임이 명확하다

  - 개발자는 본인의 역량을 온전히 도메인 기술에 집중 할 수 있다
  - 변화에 신속하게 반응하는 민첩성은 상대적으로 떨어진다

- 도메인이 모든 레이어에 포함되므로 도메인 변경에 따른 대응이 쉽지 않다
  - 일반적인 케이스로는, 서비스 구현 시 고객 도메인이 프리젠테이션부터 데이터베이스 레이어에까지 모두 포함되어 있다

## 10.2 레이어 격리

각 레이어는 폐쇄(Closed) 또는 개방(Open) 상태로 나뉜다

- 폐쇄 레이어

  - 요청이 상위 레이어에서 하위 레이어로 이동 할 때, 중간의 특정 레이어를 생략할 수 없고 반드시 해당 레이어를 거쳐야 하는 것

- 개방 레이어
  - 단순 조회와 같은 경우 비즈니스 레이어, 퍼시스턴스 레이어를 생략하고 바로 데이터베이스 레이어에 접근하는 것이 편할 것이다, 이런 방식을 추월 차선 리더 패턴(fast-lane reader pattern)이라 하며, 이런 요청 구조를 가능하게 하려면, 비즈니스 레이어와 퍼시스턴스 레이어가 개방 상태여야 한다

레이어 격리

- 레이어 격리란 특정 레이어에서 변경이 일어나도 다른 레이어의 컴포넌트에 아무 영향을 끼치지 않는 것이다
- 레이어 격리를 위해선 메인 흐름에 관한 레이어가 모두 폐쇄 상태여아 한다
- 레이어 격리를 지키지 않은 상호 의존도가 높은 레이어는 단단한 커플링으로 인해 취약점이 되고, 변경하기 힘들고 비용이 높아진다
- 레이어 격리가 잘 지켜질 경우 다른 레이어에 영향을 주지 않고 레이어를 교체할 수도 있다

## 10.3 레이어 추가

때때론 폐쇄 레이어를 이용해 격리하는 것 보다 개방하는 것이 합리적인 경우도 있다

필요에 따라 특정 레이어를 관심사의 단위로 레이어를 나누어 폐쇄와 개방을 복합적으로 사용하도록 유도하는 패턴 (책 p.186 참고)

이러한 방식은 어느 레이어가 폐쇄/개방 되어있는지 명확히 문서화하고 공유되지 않으면 테스트, 유지 보수 등 운영 비용에 큰 악영향을 미치는 아키텍처다

## 10.4 기타 고려 사항

- 아키텍처 스타일을 결정하지 못했을 경우 좋은 출발점이 될 아키텍처

  - 위와 같은 경우 재사용은 최소한으로, 객체 계층은 최대한 가볍게 맞추어 모듈성을 유지해야, 추후 다른 아키텍처 스타일로 변경할 때 수월하다

- 아키텍처 싱크홀(architecture sinkhole) 안티패턴을 조심해야 한다
  - 요청이 다음 레이어로 이동할 때, 해당 레이어가 아무 처리도 하지 않고 그냥 통과시키는 안티 패턴
  - 이러한 흐름은 불필요한 객체 초기화와 처리가 빈번히 발생하고, 메모리 낭비 등 성능에도 부정적인 영향을 준다
  - 레이어드 아키텍처에서 아키텍처 싱크홀을 완전히 억제하는 것은 거의 불가능하다, 80 대 20의 법칙으로, 전체 요청의 20%가 싱크홀인 정도면 무난한 수준으로 본다
  - 아키텍처 싱크홀을 풀기 위한 해결책으론 모든 레이어를 개방하는 방법이 있으나, 이는 아키텍처 변경 관리의 어려움이 가중된다

## 10.5 왜 이 아키텍처 스타일을 사용하는가

- 작고 단순한 애플리케이션이나 웹 사이트에 적합하다
- 예산과 일정이 빠듯할 경우 적합하다
- 개발자와 아키텍트 모두에게 친숙하다
- 아키텍트가 아직 비즈니스 니즈와 요구사항을 명확히 정리하지 못 했을 때 무난하게 시작 가능하다

- 서비스 규모가 커질수록 유지 보수성, 민첩성, 시험성, 배포성이 나빠진다

## 10.6 아키텍처 특성 등급

특출난 특성:

- 전체 비용
- 단순성

무난한 특성:

- 신뢰성

정리

- 서비스가 점점 커지고 복잡해질수록 위 특성이 점차 무의미해진다
- 배포성과 시험성 별점이 매우 낮다, 배포가 까다롭고 리스크가 높다
- 컴포넌트를 모킹하거나 스터빙할 수 있어 전체 테스트 공수가 조금 감소한다
- 모놀리식 구조로 언제나 단일 시스템 퀀텀이므로 확장에 한계가 있다
  - 억지로 확장하려면 멀티스레딩, 내부 메시징 등 모놀리식과 어울리지 않는 갖가지 병렬 처리 프랙티스와 기법을 동원해야 한다
- 병렬 처리가 거의 안되고 폐쇄적인 레이어와 싱크홀 아키텍처 안티패턴 등 문제로 고성능 시스템에 적합하지 않다
- 모듈성이 낮기 때문에 내고장성도 높지 않다, 각 레이어의 장애가 애플리케이션 전체에 영향을 준다
- 평균 수리 시간(MTTR, Mean-Time-To_recovery)은 소규모 애플리케이션은 2분, 대규모 애플리케이션은 약 15분으로 가용성도 높지 않다
