# Chap1 서론

> 아키텍처는 중요한 것들에 관한 것이다. 그게 무엇이든 말이다.
>
> - 랄프 존슨 Ralph Johnson (GoF)

- 과거의 아키텍처는 모듈성, 컴포넌트, 패턴 등 순수 기술적인 부분을 다루었지만, 최근의 역할은 업무 범위의 제한 없이 업무를 원활히하기 위한 포괄적인 업무를 수행한다
- 대부분 아키텍처 도서에서는 아키텍처를 정적인(Static) 문제로 다루지만, 이 책에선 동적인(Dynamic) 문제로 취급한다.
  - 정적: 한번 해결되고 나면 더이상 신경 안써도 되는 문제
  - 동적: 완벽하게 들어맞았던 솔루션도 이후 생태계 변화에 따라 지속적으로 변화가 필요한 문제
- 소프트웨어 아키텍트는 끊임없이 변하는 생태계 안에서 뭔가 결정을 내리는 사람들이다
- 모든 아키텍처는 그 콘텍스트의 결과물이다

## 1.1 소프트웨어 아키텍처란?

사람마다 관점이 다르지만 다음과 같은 관점으로 분석이 가능하다

- 아키텍쳐 특성
  시스템이 올바르게 동작하기 위해 필요한 특성들이다
  → 가용성, 신뢰성, 시험성, 확장성, 보안, 민첩성, 내고장성, 탄련성, 복구성, 성능, 배포성, 학습성 등
- 아키텍처 결정
  시스템 구축에 필요한 규칙들(결정 사항)
  아키텍쳐 결정은 시스템의 제약조건(Constraint)를 형성하며, 개발자가 해도 되는것과 안되는 것을 구분한다
- 설계 원칙
  아키텍처 결정이 꼭 지켜야 할 규칙(제약사항)이라면, 설계 원칙은 시스템 구축을 위한 권고 사항이다
  → ex 1) 서비스 간 성능 개선을 위해 서비스 간 통신을 비동기 메시징을 권장하는 것
  → ex 2) 특정 환경에서 개발자가 더 적합한 프로토콜(gRPC 혹 REST) 등을 선택할 수 있도록 권장하는 것
- 시스템 구조
  마이크로서비스, 레이어드, 마이크로커널 같은 아키텍처 스타일을 표현

## 1.2 아키텍트에 대한 기대치

역할, 직책, 직무에 상관없이 아키텍트에게 바라는 핵심 요구사항은 다음 여덞가지로 정리된다.

1. 아키텍처 결정을 내린다

   1. 아키텍처와 설계 원칙을 결정한다
   2. 팀, 부서뿐 아니라 회사 전체의 기술 결정을 가이드한다

      기술 결정을 가이드하는 것이지, 정하는(Specify)하는 것이 아니다

2. 아키텍처를 지속적으로 분석한다
   1. 아키텍처와 현재 기술 환경을 분석하고 이를 개선하기 위한 해결 방안을 제시한다
   2. 과거에 구성했던 아키텍처가 지금도 얼마나 현실성 있는지 평가하는 아키텍처 역동성(Viatality)이다
   3. 기술 변화와 문제 영역을 종합적으로 분석하여 아키텍처의 건전성을 추구해야 한다
3. 최신 트렌드를 계속 유지한다
   1. 핵심 트랜드를 이해해야 미래를 대비하고 올바른 결정을 내릴 수 있다
4. 아키텍처 결정의 **컴플라이언스(Compliance)**를 보장한다

   1. 아키텍트가 정의하고 문서화하여 전달한 아키텍처 결정과 설계 원칙들을 개발팀이 제대로 준수하고 있는지 지속적으로 확인해야 한다
   2. 결정 사항이 지켜지지 않는다면 처음 아키텍처 설계 당시 의도했던 아키텍처 특성을 준수할 수 없게 된다

   > 통상 법규준수 / 준법감시 / 내부통제 동의 의미로 컴플라이언스 프로그램이라 말한다
   >
   > 컴플라이언스 프로그램이란 사업 추진 과정에서 기업이 자발적으로 관련 법규를 준수하도록 하기 위한 일련의 시스템이다

5. 다양한 기술과 경험에 노출된다
   1. 다양한 기술, 프레임워크, 플랫폼, 환경에 노출되어야 한다
   2. 모든 기술을 통달해야하는 것은 아니지만, 다양한 기술을 거리낌없이 쓸 줄 알아야 한다
   3. 어떤 기술로 개발되었든지 다양한 시스템과 서비스를 연동하는 방법을 알고 있어야 한다
   4. 하나의 기술을 통달하는것보다 모든 기술의 장단점을 아는게 더 중요하다
6. 비즈니스 도메인 지식을 보유한다
   1. 비즈니스의 문제점, 목표, 요구사항을 명확히 이해하고 있어야 이를 수용할 만한 효율적인 아키텍처를 설계할 수 있다
   2. 기본 업무 지식 없이는 이해 관계자들과 소통할 수 없다
7. 대인 관계 기술이 뛰어나다
   1. 팀워크, 조정(Facilitation), 리더십을 포함한 대인 관계 기술이 필요하다
   2. 아키텍트는 개발팀을 기술적으로 이끌기만하는 사람이 아니라, 팀을 리드하여 아키텍처를 구현하는 사람이다
   3. 팀을 리드, 코치하고 개발자를 멘토링하며 아키텍처 결정과 설계 원칙, 배경 사상을 효과적으로 전달할 수 있어야 한다
8. 정치를 이해하고 처세를 잘한다
   1. 모든 결정은 이해 관계자들의 반발에 부딪히게 된다
   2. 모든 결정을 정당화하고 반대 세력과 협상이 필요하다

## 1.3 아키텍처의 교차점 그리고…

### 1.3.1 엔지니어링 프랙티스

- 과거 아키텍처는 소프트웨어를 제작하는 개발 프로세스와 단절되어 있었다. 애자일, 익스트림 프로그래밍, 린등은 소프트웨어 아키텍처에 큰 영향을 주지 않았다
- 엔지니어링 프랙티스와 소프트웨어 개발 프로세스를 구분해야 한다
  - 개발 프로세스: 팀을 어떻게 구성하고 관리할지, 회의의 진행 방식, 워크풀로 조직 운영 방침 등 조직과 상호작용하는 총체적인 기법
  - 엔지니어링 프랙티스: 가시적이고 반복 가능한 혜택을 주는 실천론, 가령 지속적 통합(Continuous intergration)은 특정 프로세스에 의존하지 않는 검증된 엔지니어링 프랙티스
- 소프트웨어 개발의 아킬레스건 중 하나는 추정(Estimation)이다.

  - `알려지지 않은 미지의 것들(unknown unknowns)`로 인해 추정은 어려울 수 밖에 없다

    > “알려진 기지의 것들”, 즉 우리가 알고 있다는 사실을 알고 있는 것들
    >
    > ”알려진 미지의 것들”, 즉 우리가 모르는 뭔가가 있다는 사실을 알고 있는 것들
    >
    > ”알려지지 않은 미지의 것들”, 우리가 모른다는 사실조차 알지 못하는 것들
    >
    > - 도널드 럼즈펠드 Donald Rumsfeld (전 미 국방부 장관)

- 모든 아키텍처는 알려지지 않은 미지의 것들이 거듭 되풀이된다. 애자일은 단지 이것을 인지해서 더 빨리 수행하는 것이다.
- 아키텍트는 기술 리드를 겸하는 경우가 많기 때문에 엔지니어링 프랙티스를 결정해야한다
- 아키텍처를 선전하기 전에 문제 영역을 주의 깊게 살펴 아키텍처 스타일과 엔지니어링 프랙티스가 공생 관계망(symbiotic provisioning)을 형성하도록 해야 한다
  - 가령 마이크로서비스 아키텍처는 머신 프로비저닝과 자동화 테스팅/배포 등을 전제로 한다
- 정적인 것은 하나도 없다. 아키텍처 피트니스 함수를 통해 시스템 구성 당시의 아키텍처 특성이 보장되고 있는지 평가하는 수단이 필요하다
  - 아키텍처의 중요한 부분이 어떤 상태인지 항시 파악해야 한다

### 1.3.2 운영/데브옵스

- 운영 관심사는 운영으로 처리해야 더 매끄럽게 해결된다
- 아키텍처와 운영 간 연결고리를 맺어, 설계를 단순화하고 운영 관심사에 맞는 부분은 운영에 맡기자

### 1.3.3 프로세스

- 모든 아키텍처는 단지 시간 문제일 뿐 반복적이다
- 애자일 방법론은 반복적인 개발을 통해 의사 결정에 필요한 피드백을 더 빨리 받고 피드백에 의존하는 방식이다
- 아직 많은 프로젝트가 정치 등 소프트웨어와 무관한 팩터로 인해 낡은 프로세스를 사용하고 있다

### 1.3.4 데이터

- 코드와 데이터는 공생 관계이며 하나만 존재해서는 무용지물이다
- 아키텍트는 데이터베이스 관리자와 협업하여 어플리케이션의 데이터 관계 및 재사용에 대해 면밀히 분석해야 한다

## 1.4 소프트웨어 아키텍처 법칙

> 소프트웨어 아키텍처의 모든 것은 다 트레이드오프다
>
> - 소프트웨어 아키텍처 제1 법칙

> ‘어떻게’보다 ‘왜’가 더 중요하다
>
> - 소프트웨어 아키텍처 제2 법칙

> 아키텍트가 트레이드오프 아닌 뭔가를 발견했다면, 그것은 아직 트레이드오프를 발견하지 못했다는 증거일 가능성이 높다
>
> - 제1 정리

- 소프트웨어 아키텍트에게 깔끔하게 딱 떨어지는 것은 하나도 없다. 모든 결정은 여러 가지 상충되는 팩터들을 전부 고려해야 한다
- 아키텍트는 왜 다른 것 대신 그런 선택을 하게 됐는지 명확하게 설명할 수 있어야 한다
